<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title></title>
  <link rel="stylesheet" href="{{ url_for('static', filename='chota.css') }}">

  <style>
    body.dark {
      --bg-color: #000;
      --bg-secondary-color: #131316;
      --font-color: #f5f5f5;
      --color-grey: #ccc;
      --color-darkGrey: #777;
    }

    .is-circle {
      border-radius: 1000px;
      height: 6vw;
      width: 6vw;
      padding-top: 2vw;
    }


    .is-narrow {
      flex: none;
      width: unset;
    }

    .narrow-col {
      width: 200px;text-align: end;
    }

    .card {
      border-radius: 0px;
      background: var(--bg-color);
      -webkit-box-shadow: 0 0px 0px 1px var(--color-grey);
      box-shadow: 0 0px 0px 1px var(--color-grey);
    }

    .button, button {
      border-radius: 0px !important;
      padding: 1rem 1rem !important;
    }

    .btn-close {
      position: absolute;
      top: 0;
      right: 0;
      border: none;
      font-size: 20px;
      padding: 10px;
      cursor: pointer;
      font-weight: bold;
      color: #4AAE9B;
      background: transparent;
    }


    input[type="text"],
    input[type="password"],
    input[type="email"],
    input[type="number"],
    input[type="tel"],
    input[type="url"],
    input[type="search"],
    textarea,
    select {
      border-radius: 0px !important;
      background-color: #333;
      color: #fff;
      border: 1px solid #555; /* Add border color */
    }



    /* For Webkit browsers (Chrome, Safari) */
    ::-webkit-scrollbar {
      width: 12px; /* Adjust width as needed */
      background-color: #333; /* Background color of the scrollbar track */
    }

    ::-webkit-scrollbar-thumb {
      background-color: #666; /* Color of the scrollbar thumb */
      border-radius: 0px; /* Rounded corners for the scrollbar thumb */
    }

    ::-webkit-scrollbar-thumb:hover {
      background-color: #888; /* Color of the scrollbar thumb on hover */
    }


    .modal-backdrop {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: rgba(0, 0, 0, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .modal {
      height: 80vh;
      width: 90vw;
      background: #232222;
      overflow-x: auto;
      /*display: flex;*/
      flex-direction: row;
    }

    .modal-body {
      position: relative;
      padding: 20px 10px;
    }

  </style>
</head>
<body>


  <script type="text/javascript" src="{{ url_for('static', filename='vue.global.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='chart.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='luxon.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='chartjs-adapter-luxon.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='regression.min.js') }}"></script>

  <style>
    body.dark {
      --bg-color: #000;
      --bg-secondary-color: #131316;
      --font-color: #f5f5f5;
      --color-grey: #ccc;
      --color-darkGrey: #777;
    }
  </style>
  
  <script>
    if (window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches) {
      document.body.classList.add('dark');
    }
    document.body.classList.add('dark');
  </script>

  <div id="app">

    <nav class="nav">
      <div class="nav-left">
        <a class="brand" href="#">MEDUSA</a>
        <a class="button primary _outline" @click="mostrarModalCalibracao = true">Ajuste</a>
        <!-- <div class="tabs">
          <a>Link 1</a>
          <a class="active">Link 2</a>
        </div> -->
      </div>
      <!-- <div class="nav-right">
      </div> -->
    </nav>


    <!-- modal start -->
    <div class="modal-backdrop" class="card" v-if="mostrarModalCalibracao">
      <div class="modal">
        <header class="modal-header">
          <button
            type="button"
            class="button btn-close error"
            @click="mostrarModalCalibracao = false"
          >&times; Fechar</button>
        </header>

        <section class="modal-body">
          <div>
            <span v-for="ch in channels" :key="ch.id" >
              <div class="bg-primary text-center" style="width: 50px;">[[ch.id]]</div>
              <span class="row">
                <span v-for="(xy, xy_i) in ch.calData.points" :key="xy_i" class="col-3 is-vertical-align">

                  <span>
                    x: <a @click="xy[0] = ch.calData.$leitura" style="cursor: pointer;">[[ ch.calData.$leitura ]]</a>
                    <input step="0.001" type="number" class="is-borderless" v-model="xy[0]" @change="fitData(ch)">
                  </span>
                  
                  <span>
                    y: <input step="0.001" type="number" class="is-borderless" v-model="xy[1]" @change="fitData(ch)">
                  </span>
                  
                  <a class="" style="cursor: pointer;padding-left: 4px;color: red;font-size: 24px" @click="ch.calData.points.splice(xy_i, 1)&&fitData(ch)">&times;</a>
                </span>
                
                <span class="col-2" style="padding-top: 22px">
                  <a class="button success" @click="ch.calData.points.push([0, 0])">&plus; novo ponto</a>
                </span>
              </span>
              <div class="row">
                <pre>r2: [[ ch.calData.r2 ]], equation: [[ ch.calData.string ]]</pre>
              </div>
              testar:
              <div>
                x: <input step="0.001" type="number" class="is-borderless" v-model="ch.calData.$testX" style="width: 300px;" @keyup="testaPonto(ch)" @change="testaPonto(ch)"> y: [[ ch.calData.$testY ]]
              </div>
              <hr>
            </span>
            
          </div>
         </section>

      </div>
    </div>
    <!-- modal end -->




    <div class="row" style="margin-top: 20px;margin-left: 20px;margin-right: 20px;">
      <div class="col-5 card">
        
        <div class="row">
          <div class="col is-narrow narrow-col">Gravação de dados</div>
          <div class="col"><span class="tag" :class="{'bg-error': !gravacaoDeDados, 'bg-success': gravacaoDeDados}">[[ gravacaoDeDados ? "LIGADA" : "DESLIGADA"]]</span></div>
        </div>

        <div class="row">
          <div class="col is-narrow narrow-col">Tempo total</div>
          <div class="col"><span class="tag bg-error">0h0min</span></div>
        </div>

        <div class="row">
          <div class="col is-narrow narrow-col">Modo</div>
          <div class="col"><span class="tag" :class="{'bg-error': modoAuto, 'bg-success': !modoAuto}">[[ !modoAuto ? "AUTO" : "MANUAL" ]]</span></div>
        </div>

        <div class="row">
          <div class="col is-narrow narrow-col">Leitura do canal</div>
          <div class="col"><span class="tag bg-dark">10ml</span></div>
        </div>

        <div class="row">
          <div class="col is-narrow narrow-col">Temperatura da água</div>
          <div class="col"><span class="tag bg-dark">19 oC</span></div>
        </div>

        <div class="row">
          <div class="col is-narrow narrow-col">Temperatura ambiente</div>
          <div class="col"><span class="tag bg-dark">23 oC</span></div>
        </div>

        
      </div>
      <div class="col">
        <div class="card" style="background: #1f53b1;padding: 0px;">
          <!-- <header>
            <h4 class="text-center">Temperatura ambiente</h4>
          </header> -->

          <div class="row text-center" style="margin-left: 0px;margin-right: 0px;">
            <div class="col" :class="{'bg-success': activeChannelId === 'ch1'}">
              <span class="text-center">Temperatura ambiente</span>
            </div>
          </div>
          
          <div class="row text-center">
            <div class="col">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch4'}">ch4</span>
            </div>
            <div class="col">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch5'}">ch5</span>
            </div>
            <div class="col">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch6'}">ch6</span>
            </div>
            <div class="col">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch7'}">ch7</span>
            </div>
          </div>
          <div class="row text-center">

            <div class="col-2">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch0'}">Temp. água</span>
            </div>

            <div class="col-3">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch8'}">ch8</span>
            </div>
            <div class="col">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch9'}">ch9</span>
            </div>
          </div>
          
          <div class="row text-center">
            <div class="col-3">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch3'}">ch3</span>
            </div>
            <div class="col-3"></div>
            <div class="col-3"></div>
            <div class="col-3">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch2'}">ch2</span>
            </div>
          </div>
          
        </div>
      </div>
    </div>

    <div v-for="channel in channels" :key="channel.id">
      <canvas v-show="channel.id === activeChannelId && t > mountTime" :ref="channel.id"></canvas>
    </div>

  </div>
  
  <script>
    const { createApp } = Vue
    CHARTS = {}

    createApp({
      watch: {},
      data() {
        return {
          mostrarModalCalibracao: false,
          activeChannelId: null,
          gravacaoDeDados: false,
          tempoTotal: null,
          modoAuto: true,
          mountTime: Infinity,
          t: 0,
          // leituraDoCanal: null,
          // temperaturaDaAgua: null,
          // temperaturaAmbiete: null,
          channels: JSON.parse(window.localStorage.getItem('channels')) || [
            {
              id: "ch0",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch1",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch2",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch3",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch4",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch5",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch6",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch7",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch8",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch9",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
          ],
        }
      },
      mounted() {
        this.mountTime = Date.now(),
        console.log("criando graficos...")
        this.channels.forEach(channel => {
          this.creatChart(channel)
        })
        console.log("ok")
        console.log("assinando eventos...")
        fetch('/api/events')
        .then(res => res.json())
        .then(eventObjArray => {
          eventObjArray.forEach(this.handleEvent)
          
          // aguarda eventos
          const evtSource = new EventSource("/api/stream");
          evtSource.onerror = (e) => {
            console.log(e)
          }
          evtSource.onmessage = (e) => {
            let eventObj = JSON.parse(e.data)
            this.handleEvent(eventObj)
          };
        })

        this.channels.forEach(ch => {
          this.fitData(ch)
        })
        
        console.log("ok")
        console.log(this)
      },
      methods: {
        testaPonto (ch) {
          if (ch.calData.$predict) {
            ch.calData.$testY = ch.calData.$predict(ch.calData.$testX)[1]
          }
        },
        lerCanal (e, ch) {
          console.log(ch)
        },
        fitData (ch) {
          let calData = ch.calData
          let r = regression.polynomial(calData.points, { order: calData.points.length-1, precision: 17 })
          // console.log(r)
          calData.r2 = r.r2
          calData.string = r.string
          calData.$predict = r.predict
          window.localStorage.setItem('channels', JSON.stringify(this.channels, (k, v) => k.startsWith('$') ? undefined : v))
          this.testaPonto(ch)
        },
        creatChart (channel) {
          const ctx = this.$refs[channel.id]
          //console.log(ctx)
          CHARTS[channel.id] = new Chart(ctx, {
            type: 'line',
            responsive: false,
            data: {
              datasets: [{
                label: '# of Votes',
                // data: new Array(5).fill().map((_, i) => [Date.now()+i, Math.random()]),
                data: [],
                borderWidth: 1
              }]
            },
            options: {
              plugins: {
                legend: {
                  display: false
                },
                title: {
                  display: true,
                  text: channel.id
                  // padding: {
                  //   top: 10,
                  //   bottom: 30
                  // }
                }
              },
              scales: {
                x: {
                  // The axis for this scale is determined from the first letter of the id as `'x'`
                  // It is recommended to specify `position` and / or `axis` explicitly.
                  type: 'time',
                  ticks: {
                    callback: function(value) { 
                      // return new Date(value).toLocaleTimeString('pt-Br', {day: 'numeric', month: 'numeric', year:'numeric'})
                      return new Date(value).toLocaleTimeString('pt-Br') // 02:02:22
                    },
                  },
                },
                y: {
                  beginAtZero: false,
                  title: {
                    display: true,
                    text: 'value'
                  }
                }
              }
            }
          });
        },
        handleEvent (eventObj) {
          if (eventObj.activeChannelId) {
            CHARTS[eventObj.activeChannelId].data.datasets[0].data.push([null, null])
          }
          if (eventObj.read !== undefined) {
            if (CHARTS[this.activeChannelId]) {
              let ch = this.channels.filter(ch => ch.id === this.activeChannelId)[0]

              let data = CHARTS[this.activeChannelId].data.datasets[0].data
              let i = data.length-1
              data[i][0] ||= eventObj.t
              data[i][1] ||= eventObj.read
              data[i][1] = data[i][1]*0.4 + eventObj.read*0.6
              
              // grava ultima leitura estabilizada para uso em dados de calibração
              // ch.calData.$leitura = data[i-1] !== undefined ? Math.round(data[i-1][1]*1000000)/1000000 : undefined
              ch.calData.$leitura = data[i] !== undefined ? Math.round(data[i][1]*1000000)/1000000 : undefined

              // faz previsão da leitura e grava nos dados do gráfico
              data[i][1] = ch.calData.$predict && !isNaN(ch.calData.r2) ? ch.calData.$predict(data[i][1])[1] : data[i][1]
              
              if (this.t > this.mountTime) {
                CHARTS[this.activeChannelId].update('none')
              }
            }
          } else {
            Object.assign(this, eventObj)
          }
        }
      },
      delimiters: ["[[", "]]"],
    }).mount('#app')
  </script>


  <script>
    // aplicar tema escuro
    //if (window.matchMedia &&
    //    window.matchMedia('(prefers-color-scheme: dark)').matches) {
    //  document.body.classList.add('dark');
    //}
  </script>
</body>
</html>
