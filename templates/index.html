<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title></title>
  <link rel="stylesheet" href="{{ url_for('static', filename='chota.css') }}">

  <style>
    body.dark {
      --bg-color: #000;
      --bg-secondary-color: #131316;
      --font-color: #f5f5f5;
      --color-grey: #ccc;
      --color-darkGrey: #777;
    }

    .is-circle {
      border-radius: 1000px;
      height: 6vw;
      width: 6vw;
      padding-top: 1.5vw;
      font-size: 20px;
      background: #b4b8be;
      color: #404040;

    }

    .is-circle > div{
      font-weight: 500;
    }

    .is-narrow {
      flex: none;
      width: unset;
    }

    .narrow-col {
      width: 180px;text-align: end;
    }

    .card {
      border-radius: 0px;
      background: var(--bg-color);
      -webkit-box-shadow: 0 0px 0px 1px var(--color-grey);
      box-shadow: 0 0px 0px 1px var(--color-grey);
    }

    .button, button {
      border-radius: 0px !important;
      padding: 1rem 1rem !important;
    }

    button, a {
      cursor: pointer !important;
    }

    .btn-close {
      position: absolute;
      top: 0;
      right: 0;
      border: none;
      font-size: 20px;
      padding: 10px;
      cursor: pointer;
      font-weight: bold;
      color: #4AAE9B;
      background: transparent;
    }


    input[type="text"],
    input[type="password"],
    input[type="email"],
    input[type="number"],
    input[type="tel"],
    input[type="url"],
    input[type="search"],
    textarea,
    select {
      border-radius: 0px !important;
      background-color: #333;
      color: #fff;
      border: 1px solid #4d4d4d !important;
    }

    .card {
      box-shadow: 0 0px 0px 1px #585858 !important;
    }



    /* For Webkit browsers (Chrome, Safari) */
    ::-webkit-scrollbar {
      width: 12px; /* Adjust width as needed */
      background-color: #333; /* Background color of the scrollbar track */
    }

    ::-webkit-scrollbar-thumb {
      background-color: #666; /* Color of the scrollbar thumb */
      border-radius: 0px; /* Rounded corners for the scrollbar thumb */
    }

    ::-webkit-scrollbar-thumb:hover {
      background-color: #888; /* Color of the scrollbar thumb on hover */
    }


    .modal-backdrop {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: rgba(0, 0, 0, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .modal {
      height: 80vh;
      width: 90vw;
      background: #232222;
      overflow-x: auto;
      /*display: flex;*/
      flex-direction: row;
    }

    .modal-body {
      position: relative;
      padding: 20px 10px;
    }

    .nav img {
      max-height: 8rem;
      padding-top: 6px;
    }

    .tag {
      text-transform: inherit;
    }

  </style>
</head>
<body style="background-color: #1b1b1b;">


  <script type="text/javascript" src="{{ url_for('static', filename='vue.global.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='chart.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='luxon.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='chartjs-adapter-luxon.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='regression.min.js') }}"></script>

  <style>
    body.dark {
      --bg-color: #000;
      --bg-secondary-color: #131316;
      --font-color: #f5f5f5;
      --color-grey: #ccc;
      --color-darkGrey: #777;
    }
  </style>
  
  <script>
    if (window.matchMedia &&
        window.matchMedia('(prefers-color-scheme: dark)').matches) {
      document.body.classList.add('dark');
    }
    document.body.classList.add('dark');

    let pow = Math.pow
  </script>

  <div id="app">
    <nav class="nav">
      <div class="nav-left">
        <a class="brand" href="#" style="pointer-events: none;"><img src="{{ url_for('static', filename='logo.svg') }}"></a>
        <!-- <a class="brand" href="#">MEDUSA</a> -->

        <span class="button text-light" :class="{'bg-error': !gravacaoDeDados, 'bg-success': gravacaoDeDados}" style="pointer-events: none;">Gravação: [[ gravacaoDeDados ? "LIGADA" : "DESLIGADA"]]</span>

        <span class="button text-light" :class="{'bg-error': modoAuto, 'bg-success': !modoAuto}" style="pointer-events: none;">Modo: [[ !modoAuto ? "AUTO" : "MANUAL" ]]</span>
        <a class="button primary _outline" @click="mostrarModalCalibracao = true">Ajuste</a>

      </div>
      <div class="nav-right">
        <img src="{{ url_for('static', filename='logoipt_bcocor2.png') }}" style="margin-right: 20px;">
      </div>
    </nav>


    <!-- modal start -->
    <div class="modal-backdrop" class="card" v-show="mostrarModalCalibracao">
      <div class="modal">
        <header class="modal-header">
          <button
            type="button"
            class="button btn-close error"
            @click="mostrarModalCalibracao = false"
          >&times; Fechar</button>
        </header>

        <section class="modal-body">
          <nav class="tabs">
            <a @click="calChannelId = ch.id" :class="{'active text-light': ch.id === calChannelId}" v-for="ch in channels" :key="ch.id">[[ ch.id ]]</a>
          </nav>

          <div>
            <span v-for="ch in channels" :key="ch.id">
              <div v-show="calChannelId === ch.id">              
                <div class="bg-primary text-center" style="width: 50px;">[[ch.id]]</div>

                <span class="row">
                  <div class="col-4">
                    <table>
                      <tr>
                        <th></th>
                        <th>x</th>
                        <th>y</th>
                      </tr>
                      <tr v-for="(xy, xy_i) in ch.calData.points" :key="xy_i">
                        <td>
                          <a @click="xy[0] = ch.calData.$leitura" style="cursor: pointer;">[[ ch.calData.$leitura ]]</a>
                        </td>
                        <td>
                          <input step="0.001" type="number" class="is-borderless" v-model="xy[0]" @change="fitData(ch)">
                        </td>
                        <td>
                          <input step="0.001" type="number" class="is-borderless" v-model="xy[1]" @change="fitData(ch)">
                        </td>
                        <td>
                          <a class="" style="cursor: pointer;padding-left: 4px;color: red;font-size: 24px" @click="ch.calData.points.splice(xy_i, 1)&&fitData(ch)">&times;</a>
                        </td>
                      </tr>
                    </table>

                    <a class="button success" @click="ch.calData.points.push([0, 0])">&plus; novo ponto</a>

                  </div>
                  <div class="col-8">
                    ordem: <input v-model="ch.calData.order" type="number" step="1" min="1" @change="fitData(ch)" @keyup="fitData(ch)">

                    equação:
                    <!-- <pre>[[ ch.calData.string ]]</pre> -->
                    <input v-model="ch.calData.function" type="text" @change="createPredict(ch)" @keyup="createPredict(ch)">
                    <div>R²: [[ ch.calData.r2 ? ch.calData.r2.toFixed(4) : 0 ]]</div>
                    
                    <div> testar x: <input step="0.001" type="number" class="is-borderless" v-model="ch.calData.$testX" style="width: 300px;" @keyup="testaPonto(ch)" @change="testaPonto(ch)"> y: [[ ch.calData.$testY ]]
                    </div>


                    <label> unidade:</label>
                    <input v-model="ch.unidade" @change="createPredict(ch)" type="text" style="width: 150px;">
                    

                    <div style="height: 40vh;">
                      <canvas :ref="ch.id+'Cal'"></canvas>
                    </div>

                  </div>
                </span>


              </div>
            </span>
            
            
          </div>
         </section>

      </div>
    </div>
    <!-- modal end -->


    <div class="row" style="margin-top: 10px;margin-left: 10px;margin-right: 10px;">
      <div class="col is-center">
        <div class="card" style="background: rgb(20 51 109);padding: 0px;width: 70vw;height: 45vh;">
          <!-- <header>
            <h4 class="text-center">Temperatura ambiente</h4>
          </header> -->

          <div class="row text-center" style="margin-left: 0px;margin-right: 0px;">
            <div class="col" :class="{'bg-success': activeChannelId === 'ch1'}">
              <span class="text-center">Temperatura ambiente</span>
            </div>
          </div>
          
          <div class="row text-center">
            <div class="col">
              <span class="tag is-circle" style="box-shadow: -2px 0px 0px 1px #a7bdc7;" :class="{'bg-success': activeChannelId === 'ch4'}">ch4
                <div>[[ channels[4].$leitura ]] [[ channels[4].unidade ]]</div>
              </span>
            </div>
            <div class="col">
              <span class="tag is-circle" style="box-shadow: -2px 0px 0px 1px #a7bdc7;" :class="{'bg-success': activeChannelId === 'ch5'}">ch5
                <div>[[ channels[5].$leitura ]] [[ channels[5].unidade ]]</div>
              </span>
            </div>
            <div class="col">
              <span class="tag is-circle" style="box-shadow: 2px 0px 0px 1px #a7bdc7;" :class="{'bg-success': activeChannelId === 'ch6'}">ch6
                <div>[[ channels[6].$leitura ]] [[ channels[6].unidade ]]</div>
              </span>
            </div>
            <div class="col">
              <span class="tag is-circle" style="box-shadow: 2px 0px 0px 1px #a7bdc7;" :class="{'bg-success': activeChannelId === 'ch7'}">ch7
                <div>[[ channels[7].$leitura ]] [[ channels[7].unidade ]]</div>
              </span>
            </div>
          </div>
          <div class="row text-center">

            <div class="col-2">
              <span class="tag is-circle" :class="{'bg-success': activeChannelId === 'ch0'}"><small>T. água</small>
                <div>[[ channels[0].$leitura ]] [[ channels[0].unidade ]]</div>
              </span>
            </div>

            <div class="col-3">
              <span class="tag is-circle" style="box-shadow: -2px 0px 0px 1px #a7bdc7;" :class="{'bg-success': activeChannelId === 'ch8'}">ch8
                <div>[[ channels[8].$leitura ]] [[ channels[8].unidade ]]</div>
              </span>
            </div>
            <div class="col">
              <span class="tag is-circle" style="box-shadow: 2px 0px 0px 1px #a7bdc7;" :class="{'bg-success': activeChannelId === 'ch9'}">ch9
                <div>[[ channels[9].$leitura ]] [[ channels[9].unidade ]]</div>
              </span>
            </div>
          </div>
          
          <div class="row text-center">
            <div class="col-3">
              <span class="tag is-circle" style="box-shadow: -2px 0px 0px 1px #a7bdc7;" :class="{'bg-success': activeChannelId === 'ch3'}">ch3
                <div>[[ channels[3].$leitura ]] [[ channels[3].unidade ]]</div>
              </span>
            </div>
            <div class="col-3"></div>
            <div class="col-3"></div>
            <div class="col-3">
              <span class="tag is-circle" style="box-shadow: 2px 0px 0px 1px #a7bdc7;" :class="{'bg-success': activeChannelId === 'ch2'}">ch2
                <div>[[ channels[2].$leitura ]] [[ channels[2].unidade ]]</div>
              </span>
            </div>
          </div>
          
        </div>
      </div>
    </div>

    <div v-for="channel in channels" :key="channel.id" class="row">
      <div class="col is-center" v-show="channel.id === activeChannelId && t > mountTime" style="height: 50vh;width: 80vw;">
        <canvas :ref="channel.id"></canvas>
      </div>
    </div>

  </div>
  
  <script>
    const { createApp } = Vue
    CHARTS = {}

    createApp({
      watch: {},
      data() {
        return {
          mostrarModalCalibracao: false,
          activeChannelId: null,
          calChannelId: 'ch0',
          gravacaoDeDados: false,
          tempoTotal: null,
          modoAuto: true,
          mountTime: Infinity,
          t: 0,
          // leituraDoCanal: null,
          // temperaturaDaAgua: null,
          // temperaturaAmbiete: null,
          channels: JSON.parse(window.localStorage.getItem('channels')) || [
            {
              id: "ch0",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch1",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch2",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch3",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch4",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch5",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch6",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch7",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch8",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
            {
              id: "ch9",
              type: "lvdt",
              chart: null,
              calData: {points: [[0,0],[0,0],[0,0],[0,0]], string: '', r2: null},
            },
          ],
        }
      },
      mounted() {
        console.log("criando graficos...")
        this.channels.forEach(channel => {
          this.createChart(channel)
          this.createCalChart(channel)
        })

        console.log("ok")
        console.log("assinando eventos...")
        fetch('/api/events')
        .then(res => res.json())
        .then(eventObjArray => {
          eventObjArray.forEach(this.handleEvent)
          
          // aguarda eventos
          const evtSource = new EventSource("/api/stream");
          evtSource.onerror = (e) => {
            console.log(e)
          }
          evtSource.onmessage = (e) => {
            let eventObj = JSON.parse(e.data)
            this.handleEvent(eventObj)
          };
        })

        this.channels.forEach(ch => {
          this.createPredict(ch)
        })
        
        window.setTimeout(() => {
          this.mountTime = Date.now()
        }, 5000)

      },
      methods: {
        testaPonto (ch) {
          if (ch.calData.$predict) {
            ch.calData.$testY = ch.calData.$predict(ch.calData.$testX)
          }
        },
        lerCanal (e, ch) {
          console.log(ch)
        },
        fitData (ch) {
          let calData = ch.calData
          let r = regression.polynomial(calData.points, { order: calData.order, precision: 17 })
          console.log(calData.order)
          // console.log(r)
          calData.r2 = r.r2
          calData.string = r.string
          // calData.$predict = r.predict
          calData.function = r.equation
            .slice(0,-1)
            .map((x, i) => `${x}*pow(x, ${r.equation.length-(i+1)})`)
            .join(' + ') + ` + ${r.equation[r.equation.length-1]}`

          this.createPredict(ch, calData)
        },
        createPredict (ch) {
          let calData = ch.calData
          calData.$predict = new Function('x', `return ${calData.function}`)
          window.localStorage.setItem('channels', JSON.stringify(this.channels, (k, v) => k.startsWith('$') ? undefined : v))

          CHARTS[ch.id+'Cal'].data.datasets[0].data = calData.points.map(x => [x[0], [x[1]]])
          CHARTS[ch.id+'Cal'].data.datasets[1].data = calData.points.map(x => [x[0], calData.$predict(x[0])])

          CHARTS[ch.id+'Cal'].options.scales.y.title.text = ch.unidade

          if (Date.now() > this.mountTime) {
            CHARTS[ch.id+'Cal'].update('none')
          }
          this.testaPonto(ch)
        },
        createCalChart (channel) {
          const ctx = this.$refs[channel.id+'Cal']
          CHARTS[channel.id+'Cal'] = new Chart(ctx, {
            type: 'scatter',
            responsive: false,
            data: {
              datasets: [{
                label: 'Pontos informados',
                data: null,
                borderWidth: 1,
                type: 'line'
              },{
                label: 'Resultado do ajuste',
                data: null,
                borderWidth: 1,
                type: 'line'
              }]
            },
            options: {
              animation: {
                  duration: 0
              },
              spanGaps: true,
              plugins: {
                legend: {
                  display: true
                },
                title: {
                  display: true,
                  text: 'Ajuste da curva'
                }
              },
              scales: {
                x: {
                  beginAtZero: false,
                  title: {
                    display: true,
                    text: 'Volts'
                  }
                },
                y: {
                  beginAtZero: false,
                  title: {
                    display: true,
                    text: ''
                  }
                }
              }
            }
          })
        },
        createChart (channel) {
          const ctx = this.$refs[channel.id]
          //console.log(ctx)
          CHARTS[channel.id] = new Chart(ctx, {
            type: 'line',
            responsive: false,
            data: {
              datasets: [{
                label: '# of Votes',
                // data: new Array(5).fill().map((_, i) => [Date.now()+i, Math.random()]),
                data: [],
                borderWidth: 1
              }]
            },
            options: {
              animation: {
                duration: 0
              },
              spanGaps: true,
              plugins: {
                legend: {
                  display: false
                },
                title: {
                  display: true,
                  text: channel.id
                  // padding: {
                  //   top: 10,
                  //   bottom: 30
                  // }
                }
              },
              scales: {
                x: {
                  // The axis for this scale is determined from the first letter of the id as `'x'`
                  // It is recommended to specify `position` and / or `axis` explicitly.
                  type: 'time',
                  ticks: {
                    callback: function(value) { 
                      // return new Date(value).toLocaleTimeString('pt-Br', {day: 'numeric', month: 'numeric', year:'numeric'})
                      return new Date(value).toLocaleTimeString('pt-Br') // 02:02:22
                    },
                  },
                },
                y: {
                  beginAtZero: false,
                  title: {
                    display: true,
                    text: 'value'
                  }
                }
              }
            }
          });

          CHARTS[channel.id].rawData = []
        },
        handleEvent (eventObj) {
          if (eventObj.render) {
            //CHARTS[this.activeChannelId].update('none')
          }
          if (eventObj.activeChannelId) {
            // modoAuto = 1, então estamos no modo manual (sim, é invertido)
            // e habilita modo free run
            if (this.modoAuto && this.t > this.mountTime) {
              CHARTS[this.activeChannelId].update('none')
            }

            CHARTS[eventObj.activeChannelId].data.datasets[0].data.push([null, null])
            CHARTS[eventObj.activeChannelId].rawData.push([null, null])
          }
          if (eventObj.read !== undefined) {
            if (CHARTS[this.activeChannelId]) {
              let ch = this.channels.filter(ch => ch.id === this.activeChannelId)[0]

              let data = CHARTS[this.activeChannelId].data.datasets[0].data
              let rawData = CHARTS[this.activeChannelId].rawData

              let i = rawData.length-1
              rawData[i][0] ||= eventObj.t
              rawData[i][1] ||= eventObj.read
              rawData[i][1] = rawData[i][1]*0.4 + eventObj.read*0.6
              
              // grava ultima leitura estabilizada para uso em dados de calibração
              ch.calData.$leitura = rawData[i] !== undefined ? Math.round(rawData[i][1]*1000000)/1000000 : undefined

              data[i][0] = rawData[i][0]
              // faz previsão da leitura e grava nos dados do gráfico
              data[i][1] = ch.calData.$predict && !isNaN(ch.calData.r2) ? ch.calData.$predict(rawData[i][1]) : rawData[i][1]
              ch.$leitura = isNaN(data[i][1]) ? '' : data[i][1].toFixed(3)
              
              if (!this.modoAuto && this.t > this.mountTime) {
                CHARTS[this.activeChannelId].update('none')
              }
            }
          } else {
            Object.assign(this, eventObj)
          }
        }
      },
      delimiters: ["[[", "]]"],
    }).mount('#app')
  </script>


  <script>
    // aplicar tema escuro
    //if (window.matchMedia &&
    //    window.matchMedia('(prefers-color-scheme: dark)').matches) {
    //  document.body.classList.add('dark');
    //}
  </script>
</body>
</html>
